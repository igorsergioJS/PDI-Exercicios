<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Asciidoctor 1.5.4">
  <title>Processamento Digital de Imagens - Exercícios</title>
  <link rel="stylesheet" href="https://asciidoclive.com/assets/asciidoctor.js/css/asciidoctor.css">
</head>

<body class="article toc2 toc-left">
  <div id="header">
    <h1>Processamento Digital de Imagens - Exercícios</h1>
    <div id="toc" class="toc2">
      <div id="toctitle">Table of Contents</div>
      <ul class="sectlevel0">
        <li><a href="#_unidade_1">Unidade 1</a>
          <ul class="sectlevel1">
            <li><a href="#_1_manipulando_pixels_de_uma_imagem">1. Manipulando pixels de uma imagem</a>
              <ul class="sectlevel2">
                <li><a href="#_1_1_regi_es">1.1. Regiões</a></li>
                <li><a href="#_1_2_troca_de_regi_es">1.2. Troca de regiões</a></li>
              </ul>
            </li>
            <li><a href="#_2_preenchendo_regi_es">2. Preenchendo regiões</a>
              <ul class="sectlevel2">
                <li><a href="#_2_1_removendo_os_objetos_dos_cantos">2.1. Removendo os objetos dos cantos</a></li>
                <li><a href="#_2_2_pintando_o_fundo_com_outro_tom_de_cinza">2.2. Pintando o fundo com outro tom de cinza</a></li>
                <li><a href="#_2_3_contagem_dos_objetos_presentes">2.3. Contagem dos objetos presentes</a></li>
                <li><a href="#_2_4_contagem_dos_buracos_e_resultado_final">2.4. Contagem dos buracos e resultado final</a></li>
              </ul>
            </li>
            <li><a href="#_3_manipula_o_de_histogramas">3. Manipulação de histogramas</a>
              <ul class="sectlevel2">
                <li><a href="#_3_1_equalizador">3.1 Equalizador</a></li>
                <li><a href="#_3_2_detec_o_de_movimento">3.2 Detecção de movimento</a></li>
              </ul>
            </li>
            <li><a href="#_4_filtro_espacial_laplaciano_do_gaussiano">4. Filtro espacial - Laplaciano do gaussiano</a></li>
          </ul>
        </li>
        <li><a href="#_unidade_2">Unidade 2</a>
          <ul class="sectlevel1">
            <li><a href="#_1_filtro_homom_rfico">1. Filtro Homomórfico</a></li>
            <li><a href="#_2_canny_e_a_arte_do_pointilhismo">2. Canny e a Arte do pointilhismo</a></li>
            <li><a href="#_3_kmeans">3. Kmeans</a></li>
            <li><a href="#_4_morfologia_matem_tica">4. Morfologia Matemática</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  <div id="content">
    <div id="preamble">
      <div class="sectionbody">
        <div class="paragraph">
          <p>Olá, meu nome é Igor Sérgio e essa página contém a resolução comentada
            dos exercícios propostos para a disciplina Processamento Digital de Imagens
            - DCA0445 (UFRN).</p>
        </div>
      </div>
    </div>
    <h1 id="_unidade_1" class="sect0">Unidade 1</h1>
    <div class="sect1">
      <h2 id="_1_manipulando_pixels_de_uma_imagem">1. Manipulando pixels de uma imagem</h2>
      <div class="sectionbody">
        <div class="sect2">
          <h3 id="_1_1_regi_es">1.1. Regiões</h3>
          <div class="paragraph">
            <p>Utilizando o programa indicado como referência, foi implementado um programa
              que solicita ao usuário as coordenadas de dois pontos \(P_1\) e \(P_2\),
              indicando uma região para a imagem em tons de cinza se tornar negativa.</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
const int MAX = 100;

int main(int, char**){
  cv::Mat image;
  cv::Vec3b val;
  char nome_img[MAX] = "biel.png"; // Definir inicialmente o nome do arquivo a ser editado.

  int x1, x2, y1, y2;

  std:: cout &lt;&lt; "Inserir x1, x2, y1, y2:" &lt;&lt; std::endl;
  std:: cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; y1 &gt;&gt; y2;

  image= cv::imread(nome_img,cv::IMREAD_GRAYSCALE);
  if(!image.data)
    std::cout &lt;&lt; "nao abriu" &lt;&lt; nome_img &lt;&lt; std::endl;

  cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

  for(int i=x1;i&lt;x2;i++){ // 200 to 210
    for(int j=y1;j&lt;y2;j++){ // 10 to 200
      image.at&lt;uchar&gt;(i,j)= 255 - image.at&lt;uchar&gt;(i,j);
    }
  }

  cv::imshow("janela", image);
  cv::imwrite("negativo.png", image);
  cv::waitKey();


  return 0;
}</code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Original:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//biel.png" alt="biel">
            </div>
          </div>
          <div class="paragraph">
            <p>Com efeito aplicado na região escolhida:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//negativo.png" alt="negativo">
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_1_2_troca_de_regi_es">1.2. Troca de regiões</h3>
          <div class="paragraph">
            <p>Com o mesmo programa anterior usado como referência, ocorre agora a troca
              dos quadrantes em diagonal. Identificando os limites no plano de todos
              os quadrantes, basta aplicar em uma nova imagem vazia os quadrantes
              trocados diagonalmente.</p>
          </div>
          <div class="paragraph">
            <p>Original:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//biel.png" alt="biel">
            </div>
          </div>
          <div class="paragraph">
            <p>Com quadrantes trocados em diagonal:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//Troca.png" alt="Troca">
            </div>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
const int MAX = 100;

int main(int, char**){
  cv::Mat image, img_clone;

  int largura, altura;

  char nome_img[MAX] = "biel.png"; // Definir inicialmente o nome do arquivo a ser editado.


  image= cv::imread(nome_img,cv::IMREAD_GRAYSCALE);
  if(!image.data)
    std::cout &lt;&lt; "nao abriu" &lt;&lt; nome_img &lt;&lt; std::endl;

  cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

      largura = image.size().width;
      altura = image.size().height;

   // Primeiro quadrante
    img_clone = image.clone();

    for(int i=0;i&lt;altura/2;i++){
    for(int j=0;j&lt;largura/2;j++){
      img_clone.at&lt;uchar&gt;(i,j) = image.at&lt;uchar&gt;(i+altura/2,j+largura/2);
      img_clone.at&lt;uchar&gt;(i+altura/2,j+largura/2) = image.at&lt;uchar&gt;(i,j);
      img_clone.at&lt;uchar&gt;(i+altura/2,j) = image.at&lt;uchar&gt;(i,j+largura/2);
      img_clone.at&lt;uchar&gt;(i,j+largura/2) = image.at&lt;uchar&gt;(i+altura/2,j);
    }
  }


  cv::imshow("janela", img_clone);
  imwrite("Troca.png", img_clone);
  cv::waitKey();


  return 0;
}</code></pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_2_preenchendo_regi_es">2. Preenchendo regiões</h2>
      <div class="sectionbody">
        <div class="imageblock">
          <div class="content">
            <img src="image//bolhas.png" alt="Imagem Original">
          </div>
        </div>
        <div class="paragraph">
          <p>Para o problema em questão, caso existam mais de 255 objetos na cena o
            comprometimento se deve a limitação do tipo uchar. A utilização de outro
            tipo primitivo, como um inteiro.</p>
        </div>
        <div class="paragraph">
          <p>Para contabilizar a quantidade de figuras inteiras, com bolhas e remover
            imagens incompletas que tocam nas bordas, foi utilizada a seguinte solução:</p>
        </div>
        <div class="sect2">
          <h3 id="_2_1_removendo_os_objetos_dos_cantos">2.1. Removendo os objetos dos cantos</h3>
          <div class="paragraph">
            <p>Para remover os objetos que encostam nas bordas da imagem, foi usada
              uma condição que se o pixel em questão for branco e estiver em contato
              com alguma das bordas, o algoritmo do floodfill é chamado para preencher
              todos os píxels brancos vizinhos por pixels pretos, até o objeto está
              totalmente removido.</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//cantos.png" alt="Objetos que encostam os cantos removidos">
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_2_2_pintando_o_fundo_com_outro_tom_de_cinza">2.2. Pintando o fundo com outro tom de cinza</h3>
          <div class="paragraph">
            <p>Utilizando o tom de cinza de valor 100, todo o fundo preto da imagem
              é preenchido fazendo uma chamada única da função floodfield.</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//fundocinza.png" alt="Fundo alterado para outro tom de cinza">
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_2_3_contagem_dos_objetos_presentes">2.3. Contagem dos objetos presentes</h3>
          <div class="paragraph">
            <p>Reaproveitando o mesmo laço encadeado utilizado no exemplo, é feito o
              labeling os objetos, assim como a contagem total.</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//contagemTotal.png" alt="Imagem após contagem total. Talvez imperceptível, mas o tom de cinza vai ficando cada vez mais claro no preencimento dos objetos a medida que os objetos se localizam mais abaixo da figura">
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_2_4_contagem_dos_buracos_e_resultado_final">2.4. Contagem dos buracos e resultado final</h3>
          <div class="paragraph">
            <p>Agora, basta procurar na imagem os pixels com valor 0 e incrementar o
              contador seguido da região em questão ser preenchida com outro tom
              de cinza.</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//contagemBuracos.png" alt="Buracos após serem rotulados">
            </div>
          </div>
          <div class="paragraph">
            <p>Assim, os resultados procurados podem ser obtidos pelo terminal após
              a execução do código.</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//console.png" alt="console">
            </div>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(int argc, char** argv) {
  cv::Mat image, realce;
  int width, height;
  int nobjects, nholes;

  cv::Point p;
  image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

  if (!image.data) {
    std::cout &lt;&lt; "imagem nao carregou corretamente\n";
    return (-1);
  }

  width = image.cols;
  height = image.rows;
  std::cout &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; std::endl;

  p.x = 0;
  p.y = 0;

  //Remover objetos dos cantos
  for (int i = 0; i &lt; height; i++) {
    for (int j = 0; j &lt; width; j++) {
      if (image.at&lt;uchar&gt;(i, j) == 255 &amp;&amp; (i == 0 || i == width - 1 || j == 0 || j == height - 1)) {
        p.x = j;
        p.y = i;
        cv::floodFill(image, p, 0);
      }
    }
  }
  cv::imwrite("cantos.png", image);

  //Pintar o fundo de outro tom de cinza
  p.x = 0;
  p.y = 0;
  cv::floodFill(image, p, 100);
   cv::imwrite("fundocinza.png", image);


  // busca objetos presentes
  nobjects = 0;
  for (int i = 0; i &lt; height; i++) {
    for (int j = 0; j &lt; width; j++) {
      if (image.at&lt;uchar&gt;(i, j) == 255) {
        // achou um objeto
        nobjects++;
        // para o floodfill as coordenadas
        // x e y sao trocadas.
        p.x = j;
        p.y = i;
        // preenche o objeto com o contador
        cv::floodFill(image, p, nobjects);
      }
    }
  }

  cv::imwrite("contagemTotal.png", image);

    nholes = 0;
  for (int i = 0; i &lt; height; i++) {
    for (int j = 0; j &lt; width; j++) {
      if (image.at&lt;uchar&gt;(i, j) == 0) {
        nholes++;
        p.x = j;
        p.y = i;
        cv::floodFill(image, p, nholes);
      }
    }
  }


  cv::imwrite("contagemBuracos.png", image);


  std::cout &lt;&lt; "a figura tem: " &lt;&lt; nobjects &lt;&lt; " objetos, sendo: \n"&lt;&lt; nobjects - nholes &lt;&lt; " bolhas completas e " &lt;&lt; nholes &lt;&lt; " buracos. \n";

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_3_manipula_o_de_histogramas">3. Manipulação de histogramas</h2>
      <div class="sectionbody">
        <div class="sect2">
          <h3 id="_3_1_equalizador">3.1 Equalizador</h3>
          <div class="paragraph">
            <p>Para equalizar a captura de vídeo, foi feita a conversão para tons de
              cinza da imagem de entrada, assim como sua equalização pela função
              equalizeHist. Assim foi possível calcular os histogramas normalizados.</p>
          </div>
          <div class="paragraph">
            <p>Pouca iluminação ambiente:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//equalize.png" alt="Na esquerda a imagem original convertida para tons de cinza e na direita a imagem equalizda. Ambas com histograma amostra ">
            </div>
          </div>
          <div class="paragraph">
            <p>Iluminação adequada:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//equalize2.png" alt="Resultado esperado para um local mais iluminado, levando em consideração que a equalização apresenta resultados mais favoráveis para visualização para imagens com tons mais escuros">
            </div>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(int argc, char** argv){
  cv::Mat image, cinza, saida, histG, histE;
  int width, height;
  cv::VideoCapture cap;
  std::vector&lt;cv::Mat&gt; planes;
  int nbins = 64;
  float range[] = {0, 255};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;
  int key;

	cap.open(1);

  if(!cap.isOpened()){
    std::cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
  cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
  width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
  height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);

  std::cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; std::endl;
  std::cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; std::endl;

  int histw = nbins, histh = nbins/2;
  cv::Mat histGimg(histh, histw, CV_BGR2GRAY, Scalar(0));
  cv::Mat histEimg(histh, histw, CV_BGR2GRAY, Scalar(0));


  while(1){
    //captura a imagem
    cap &gt;&gt; image;
    //transforma para escala de cinza
    cvtColor( image, cinza, CV_BGR2GRAY );
    //equaliza o histograma
    equalizeHist( cinza, saida );

    calcHist(&amp;cinza, 1, 0, Mat(), histG, 1, &amp;nbins, &amp;histrange, uniform, acummulate);

    calcHist(&amp;saida, 1, 0, Mat(), histE, 1, &amp;nbins, &amp;histrange, uniform, acummulate);

    normalize(histG, histG, 0, histGimg.rows, NORM_MINMAX, -1, Mat());
    normalize(histE, histE, 0, histEimg.rows, NORM_MINMAX, -1, Mat());

    histGimg.setTo(Scalar(0));
    histEimg.setTo(Scalar(0));

    for(int i=0; i&lt;nbins; i++){
      line(histGimg,
           Point(i, histh),
           Point(i, histh-cvRound(histG.at&lt;float&gt;(i))),
           Scalar(255), 1, 8, 0);
      line(histEimg,
           Point(i, histh),
           Point(i, histh-cvRound(histE.at&lt;float&gt;(i))),
           Scalar(255), 1, 8, 0);
    }

    histGimg.copyTo(cinza(cv::Rect(0, 0,nbins, histh)));
    histEimg.copyTo(saida(cv::Rect(0, 0,nbins, histh)));

    imshow("Original", saida);
    imshow("cinza", cinza);

    key = cv::waitKey(30);
    if(key == 27) break;
  }
  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_3_2_detec_o_de_movimento">3.2 Detecção de movimento</h3>
          <div class="paragraph">
            <p>Reaproveitando boa parte do código do item anterior e comparando os histogramas
              como indicado no enunciado do exercício, foi possível obter o seguinte
              resultado:</p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img src="image//motiondetector.gif" alt="motiondetector">
            </div>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(int argc, char** argv){
  Mat image, hist0, hist1, cinza;
  int width, height;
  cv::VideoCapture cap;
  std::vector&lt;cv::Mat&gt; planes;
  int nbins = 64;
  float range[] = {0, 256};
  double comparar;
  int cont = 0;
  double limiar = 0.99;
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;
  int key;

	cap.open(1);

  if(!cap.isOpened()){
    std::cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
  cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
  width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
  height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);

  std::cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; std::endl;
  std::cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; std::endl;

    calcHist(&amp;cinza, 1, 0, Mat(), hist0, 1, &amp;nbins, &amp;histrange, uniform, acummulate);

  while(1){
    //captura a imagem
    cap &gt;&gt; image;

    cvtColor( image, cinza, CV_BGR2GRAY );

    calcHist(&amp;cinza, 1, 0, Mat(), hist1, 1, &amp;nbins, &amp;histrange, uniform, acummulate);

    comparar = compareHist(hist0, hist1, CV_COMP_CORREL);

    if(comparar &lt; limiar)
    {
        std::cout &lt;&lt; "Movimento Detectado" &lt;&lt; "(" &lt;&lt; cont &lt;&lt; ")" &lt;&lt; "!!! \n ";
        cont++;
    }
    imshow("image", image);

    calcHist(&amp;cinza, 1, 0, Mat(), hist0, 1, &amp;nbins, &amp;histrange, uniform, acummulate);

    key = cv::waitKey(30);
    if(key == 27) break;
  }
  return 0;
}</code></pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_4_filtro_espacial_laplaciano_do_gaussiano">4. Filtro espacial - Laplaciano do gaussiano</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Realizando uma convolução entre as duas máscaras, foi obtido como resultado
            uma nova máscara 5x5 responsável pela transformação solicitada no exercício.</p>
        </div>
        <div class="paragraph">
          <p>Seguem as imagens capturadas em tons de cinza, com o filtro laplaciano
            e com o laplaciano do gaussiano, respectivamente:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//laplace.png" alt="laplace">
          </div>
        </div>
        <div class="paragraph">
          <p>Observa-se que o filtro obtido pela convolução atenua as diferenças entre
            tons claros e escuros, causando um maior contraste, assim como maior
            formação de falso contorno.</p>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

void printmask(cv::Mat &amp;m)
{
    for (int i = 0; i &lt; m.size().height; i++)
    {
        for (int j = 0; j &lt; m.size().width; j++)
        {
            std::cout &lt;&lt; m.at&lt;float&gt;(i, j) &lt;&lt; ",";
        }
        std::cout &lt;&lt; "\n";
    }
}

int main(int, char **)
{
    cv::VideoCapture cap;  // open the default camera

    float lap_gauss[]= {0,0,-1,0,0,
                                   0,-1,-2,-1,0,
                                   -1,-2,16,-2,-1,
                                   0,-1,-2,-1,0,
                                   0,0,-1,0,0
                                  };
    float media[] = {0.1111, 0.1111, 0.1111, 0.1111, 0.1111,
                     0.1111, 0.1111, 0.1111, 0.1111
                    };
    float gauss[] = {0.0625, 0.125,  0.0625, 0.125, 0.25,
                     0.125,  0.0625, 0.125,  0.0625
                    };
    float horizontal[] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
    float vertical[] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
    float laplacian[] = {0, -1, 0, -1, 4, -1, 0, -1, 0};
    float boost[] = {0, -1, 0, -1, 5.2, -1, 0, -1, 0};

    cv::Mat frame, framegray, frame32f, frameFiltered;
    cv::Mat mask(3, 3, CV_32F);
    cv::Mat result;
    double width, height;
    int absolut;
    char key;

    cap.open(1);

    if (!cap.isOpened())  // check if we succeeded
        return -1;

    cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
    width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
    height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
    std::cout &lt;&lt; "largura=" &lt;&lt; width &lt;&lt; "\n";
    ;
    std::cout &lt;&lt; "altura =" &lt;&lt; height &lt;&lt; "\n";
    ;
    std::cout &lt;&lt; "fps    =" &lt;&lt; cap.get(cv::CAP_PROP_FPS) &lt;&lt; "\n";
    std::cout &lt;&lt; "format =" &lt;&lt; cap.get(cv::CAP_PROP_FORMAT) &lt;&lt; "\n";

    cv::namedWindow("filtroespacial", cv::WINDOW_NORMAL);
    cv::namedWindow("original", cv::WINDOW_NORMAL);

    mask = cv::Mat(3, 3, CV_32F, media);

    absolut = 1;  // calcs abs of the image

    for (;;)
    {
        cap &gt;&gt; frame;  // get a new frame from camera
        cv::cvtColor(frame, framegray, cv::COLOR_BGR2GRAY);
        cv::flip(framegray, framegray, 1);
        cv::imshow("original", framegray);
        framegray.convertTo(frame32f, CV_32F);
        cv::filter2D(frame32f, frameFiltered, frame32f.depth(), mask,
                     cv::Point(1, 1), 0);
        if (absolut)
        {
            frameFiltered = cv::abs(frameFiltered);
        }

        frameFiltered.convertTo(result, CV_8U);

        cv::imshow("filtroespacial", result);

        key = (char)cv::waitKey(10);
        if (key == 27) break;  // esc pressed!
        switch (key)
        {
        case 'a':
            absolut = !absolut;
            break;
        case 'm':
            mask = cv::Mat(3, 3, CV_32F, media);
            printmask(mask);
            break;
        case 'g':
            mask = cv::Mat(3, 3, CV_32F, gauss);
            printmask(mask);
            break;
        case 'h':
            mask = cv::Mat(3, 3, CV_32F, horizontal);
            printmask(mask);
            break;
        case 'v':
            mask = cv::Mat(3, 3, CV_32F, vertical);
            printmask(mask);
            break;
        case 'l':
            mask = cv::Mat(3, 3, CV_32F, laplacian);
            printmask(mask);
            break;
        case 'b':
            mask = cv::Mat(3, 3, CV_32F, boost);
            break;

        case 'f':
            mask = cv::Mat(5, 5, CV_32F, lap_gauss);
            printmask(mask);
            break;


        default:
            break;
        }
    }
    return 0;
}</code></pre>
          </div>
        </div>
      </div>
    </div>
    <h1 id="_unidade_2" class="sect0">Unidade 2</h1>
    <div class="sect1">
      <h2 id="_1_filtro_homom_rfico">1. Filtro Homomórfico</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Utilizando o programa exemplos/dftfilter.cpp como referência, implemente
            o filtro homomórfico para melhorar imagens com iluminação irregular.
            Crie uma cena mal iluminada e ajuste os parâmetros do filtro homomórfico
            para corrigir a iluminação da melhor forma possível. Assuma que a imagem
            fornecida é em tons de cinza.</p>
        </div>
        <div class="paragraph">
          <p>O filtro homomórfico é utilizado corrigir problemas de iluminação em imagens,
            possuindo os seguintes parâmetros:</p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Gama L: Limite mínimo da componente de baixa frequência da imagem (iluminância);</p>
            </li>
            <li>
              <p>Gama H: Limite máximo da componente de alta frequência da imagem (reflectância);</p>
            </li>
            <li>
              <p>C: Taxa de velocidade;</p>
            </li>
            <li>
              <p>D0: Frequência de corte do espectro;</p>
            </li>
          </ul>
        </div>
        <div class="paragraph">
          <p>A imagem principal é convertida para tons de cinza e os trackbars que modificam
            os parâmetros da função estão setados com valores iniciais.</p>
        </div>
        <div class="paragraph">
          <p>A função principal utilizada a equação que define o filtro ideal para o
            filtro homomórfico.</p>
        </div>
        <div class="paragraph">
          <p>O resultado da utilização do filtro pode ser vista na imagem seguinte:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//antesdepois.png" alt="antesdepois">
          </div>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

cv::Mat image;

// valores utilizados no filtro e trackbars
float gammaH = 0, gammaL = 0, c = 0, d0 = 0;
float gammaHMax = 100, gammaLMax = 100, cMax = 250, d0Max = 100,
      trackbarMax = 100;
int gammaHSlider = 0, gammaLSlider = 0, cSlider = 0, d0Slider = 0;

// troca os quadrantes da imagem da DFT
void swapImageQuadrants(cv::Mat &amp;image) {
    cv::Mat tmp, A, B, C, D;

    // se a imagem tiver tamanho impar, recorta a regiao para
    // evitar cópias de tamanho desigual
    image = image(cv::Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
    int cx = image.cols / 2;
    int cy = image.rows / 2;

    // reorganiza os quadrantes da transformada
    // A B   -&gt;  D C
    // C D       B A
    A = image(cv::Rect(0, 0, cx, cy));
    B = image(cv::Rect(cx, 0, cx, cy));
    C = image(cv::Rect(0, cy, cx, cy));
    D = image(cv::Rect(cx, cy, cx, cy));

    // A &lt;-&gt; D
    A.copyTo(tmp);
    D.copyTo(A);
    tmp.copyTo(D);

    // C &lt;-&gt; B
    C.copyTo(tmp);
    B.copyTo(C);
    tmp.copyTo(B);
}

void homomorphicFilter() {
    cv::Mat imaginaryInput, complexImage, multsp;
    cv::Mat padded, filter, mag;
    cv::Mat imagegray, tmp;
    cv::Mat_&lt;float&gt; realInput, zeros;
    std::vector&lt;cv::Mat&gt; planos;

    // valores ideais dos tamanhos da imagem
    // para calculo da DFT
    int dft_M, dft_N;

    // identifica os tamanhos otimos para
    // calculo do FFT
    dft_M = cv::getOptimalDFTSize(image.rows);
    dft_N = cv::getOptimalDFTSize(image.cols);

    // realiza o padding da imagem
    cv::copyMakeBorder(image, padded, 0, dft_M - image.rows, 0,
                       dft_N - image.cols, cv::BORDER_CONSTANT,
                       cv::Scalar::all(0));

    // parte imaginaria da matriz complexa (preenchida com zeros)
    zeros = cv::Mat_&lt;float&gt;::zeros(padded.size());

    // prepara a matriz complexa para ser preenchida
    complexImage = cv::Mat(padded.size(), CV_32FC2, cv::Scalar(0));

    // a função de transferencia (filtro de frequencia) deve ter o
    // mesmo tamanho e tipo da matriz complexa
    filter = complexImage.clone();

    // cria uma matriz temporária para criar as componentes real
    // e imaginaria do filtro ideal
    tmp = cv::Mat(dft_M, dft_N, CV_32F);

    // prepara o filtro homomorfico
    for (int i = 0; i &lt; dft_M; i++) {
        for (int j = 0; j &lt; dft_N; j++) {
            float d = std::pow(
                std::pow(i - dft_M / 2, 2) + std::pow(j - dft_N / 2, 2), 0.5);
            tmp.at&lt;float&gt;(i, j) =
                (gammaH - gammaL) *
                    (1 -
                     std::exp(-1 * c * (std::pow(d, 2) / std::pow(d0, 2)))) +
                gammaL;
        }
    }

    // cria a matriz com as componentes do filtro e junta
    // ambas em uma matriz multi-canal complexa
    cv::Mat comps[] = {tmp, tmp};
    cv::merge(comps, 2, filter);

    // limpa o array de matrizes que vao compor a
    // imagem complexa
    planos.clear();

    // cria a compoente real
    realInput = cv::Mat_&lt;float&gt;(padded);

    // insere as duas componentes no array de matrizes
    planos.push_back(realInput);
    planos.push_back(zeros);

    // combina o array de matrizes em uma unica
    // componente complexa
    cv::merge(planos, complexImage);

    // calcula o dft
    cv::dft(complexImage, complexImage);

    // realiza a troca de quadrantes
    swapImageQuadrants(complexImage);

    // aplica o filtro de frequencia
    cv::mulSpectrums(complexImage, filter, complexImage, 0);

    // limpa o array de planos
    planos.clear();

    // separa as partes real e imaginaria para modifica-las
    cv::split(complexImage, planos);

    // recompoe os planos em uma unica matriz complexa
    cv::merge(planos, complexImage);

    // troca novamente os quadrantes
    swapImageQuadrants(complexImage);

    // calcula a DFT inversa
    cv::idft(complexImage, complexImage);

    // limpa o array de planos
    planos.clear();

    // separa as partes real e imaginaria da
    // imagem filtrada
    cv::split(complexImage, planos);

    // normaliza a parte real para exibicao
    cv::normalize(planos[0], planos[0], 0, 1, cv::NORM_MINMAX);

    cv::imshow("Filtro Homomorfico", planos[0]);
}

void on_trackbar_gamma_h(int, void *) {
    gammaH = gammaHSlider * gammaHMax / trackbarMax;
    homomorphicFilter();
}

void on_trackbar_gamma_l(int, void *) {
    gammaL = (float)gammaLSlider;
    gammaL = gammaLMax * gammaL / trackbarMax;
    homomorphicFilter();
}

void on_trackbar_c(int, void *) {
    c = cSlider * cMax / trackbarMax;
    homomorphicFilter();
}

void on_trackbar_d0(int, void *) {
    d0 = d0Slider * d0Max / trackbarMax;
    homomorphicFilter();
}

int main(int, char **) {
    char trackbarName[50];

    // carrega a imagem e a converte para escala de cinza
    image = cv::imread("face.jpg");
    cv::cvtColor(image, image, cv::COLOR_BGR2GRAY);

    cv::namedWindow("Filtro Homomorfico");

    // configura as trackbars
    sprintf(trackbarName, "gamma_H");
    cv::createTrackbar(trackbarName, "Filtro Homomorfico", &amp;gammaHSlider,
                       trackbarMax, on_trackbar_gamma_h);

    sprintf(trackbarName, "gamma_L");
    cv::createTrackbar(trackbarName, "Filtro Homomorfico", &amp;gammaLSlider,
                       trackbarMax, on_trackbar_gamma_l);

    sprintf(trackbarName, "C");
    cv::createTrackbar(trackbarName, "Filtro Homomorfico", &amp;cSlider,
                       trackbarMax, on_trackbar_c);

    sprintf(trackbarName, "D0");
    cv::createTrackbar(trackbarName, "Filtro Homomorfico", &amp;d0Slider,
                       trackbarMax, on_trackbar_d0);

    homomorphicFilter();

    cv::waitKey(0);

    return 0;
}</code></pre>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_2_canny_e_a_arte_do_pointilhismo">2. Canny e a Arte do pointilhismo</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Utilizando os programas exemplos/canny.cpp e exemplos/pontilhismo.cpp como
            referência, implemente um programa cannypoints.cpp. A idéia é usar as
            bordas produzidas pelo algoritmo de Canny para melhorar a qualidade da
            imagem pontilhista gerada. A forma como a informação de borda será usada
            é livre.</p>
        </div>
        <div class="paragraph">
          <p>A ideia para melhorar a qualidade da imagem gerada foi de dimiuir o raio
            dos circulos, tornando os menores e trazendo mais definição a imagem
            final.</p>
        </div>
        <div class="paragraph">
          <p>Imagem original:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//ladyonfire.webp" alt="ladyonfire">
          </div>
        </div>
        <div class="paragraph">
          <p>Imagem bordas de Canny antes da melhoria:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//cannyborders_before.png" alt="cannyborders before">
          </div>
        </div>
        <div class="paragraph">
          <p>Imagem bordas de Canny após a melhoria:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//cannyborders_after.png" alt="cannyborders after">
          </div>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include "opencv2/opencv.hpp"
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;numeric&gt;

using namespace std;
using namespace cv;

#define STEP 4
#define JITTER 3
#define RAIO 5
#define RAIO_PEQUENO 2

int main(int argc, char **argv)
{
  int width, height, limite_inferior = 80;
  int x, y;
  vector&lt;int&gt; xrange, yrange;
  vector&lt;Vec6i&gt; pontos;
  Mat points, image, border, image_bw;
  Vec3b gray;

  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);

  cvtColor(image, image_bw, CV_BGR2GRAY);

  width = image.size().width;
  height = image.size().height;

  //Aplica o algoritmo de canny na imagem
  Canny(image_bw, border, limite_inferior, 3 * limite_inferior);
  imshow("bordas_canny", border);
  waitKey();

  //Obtem imagem pontilhista
  xrange.resize(height / STEP);
  yrange.resize(width / STEP);

  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  //Realiza amostragem dos pontos
  for (uint i = 0; i &lt; xrange.size(); i++)
  {
    xrange[i] = xrange[i] * STEP + STEP / 2;
  }

  for (uint i = 0; i &lt; yrange.size(); i++)
  {
    yrange[i] = yrange[i] * STEP + STEP / 2;
  }

  points = Mat(height, width, CV_8UC3, Scalar(255, 255, 255));

  random_shuffle(xrange.begin(), xrange.end());

  for (auto i : xrange)
  {
    random_shuffle(yrange.begin(), yrange.end());
    for (auto j : yrange)
    {
      x = i + rand() % (2 * JITTER) - JITTER + 1;
      y = j + rand() % (2 * JITTER) - JITTER + 1;

      //Impede o algoritmo de pegar pontos além dos limites da imagem
      if (x &gt;= height)
      {
        x = height - 1;
      }
      if (y &gt;= width)
      {
        y = width - 1;
      }

      gray = image.at&lt;Vec3b&gt;(x, y);
      circle(points,
             cv::Point(y, x),
             RAIO,
             Scalar(gray[0], gray[1], gray[2]),
             -1,
             CV_AA);
    }
  }

  imshow("imagem_pontilhista", points);
  imwrite("cannyborders_before.png", points);
  waitKey();

  //Percorre matriz em busca da borda gerada pelo algoritmo de canny para
  //desenhar pontos pequenos
  for (int i = 0; i &lt; height; i++)
  {
    for (int j = 0; j &lt; width; j++)
    {
      if (border.at&lt;uchar&gt;(i, j) != 0)
      {
        //Armazena a cor origina do ponto, bem como sua posição na
        //estrutura Vec6i, que armazena 6 inteiros
        gray = image.at&lt;Vec3b&gt;(i, j);
        pontos.push_back(Vec6i(j, i, gray[0], gray[1], gray[2], 0));
      }
    }
  }

  random_shuffle(pontos.begin(), pontos.end());

  //Desenha pontos pequenos na imagem
  Scalar cor;
  for (int i = 0; i &lt; pontos.size(); i++)
  {
    Point p(pontos.at(i)[0], pontos.at(i)[1]);
    cor = Scalar(pontos.at(i)[2], pontos.at(i)[3], pontos.at(i)[4]);
    circle(points,
           p,
           RAIO_PEQUENO,
           cor,
           -1,
           CV_AA);
  }

  imshow("imagem_pontilhista_corrigida", points);
  waitKey();

  imwrite("cannyborders_after.png", points);
  return 0;
}</code></pre>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_3_kmeans">3. Kmeans</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Utilizando o programa kmeans.cpp como exemplo prepare um programa exemplo
            onde a execução do código se dê usando o parâmetro nRodadas=1 e inciar
            os centros de forma aleatória usando o parâmetro KMEANS_RANDOM_CENTERS
            ao invés de KMEANS_PP_CENTERS. Realize 10 rodadas diferentes do algoritmo
            e compare as imagens produzidas. Explique porque elas podem diferir tanto.</p>
        </div>
        <div class="paragraph">
          <p>Após as 10 iterações, foram salvas 10 imagens e criado um gif:</p>
        </div>
        <div class="paragraph">
          <p>Imagem original:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//YellowSubmarine.jpg" alt="YellowSubmarine">
          </div>
        </div>
        <div class="paragraph">
          <p>gif gerado com as 10 imagens:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//yellowsubmarine2.gif" alt="yellowsubmarine2">
          </div>
        </div>
        <div class="paragraph">
          <p>O efeito gerado pela diferença presente em cada imagem gerada pelas iterações
            se deve a escolha aleatória dos centros, após a mudança do parâmetro
            especificado no enunciado do exercício.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_4_morfologia_matem_tica">4. Morfologia Matemática</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Usando o programa morfologia.cpp como referência, crie um programa que
            resolva o problema da pré-filtragem de forma para reconhecimento dos
            caracteres usando operações morfológicas. Você poderá usar as imagens
            digitos-1.png, digitos-2.png, digitos-3.png, digitos-4.png e digitos-5.png
            para testar seu programa. Cuidado para deixar o ponto decimal separado
            dos demais dígitos para evitar um reconhecimento errado do número no
            visor.</p>
        </div>
        <div class="paragraph">
          <p>A ideia utilizada para resolver o exercício foi a sucessão de diversas
            dilatações e erosões, que basicamente tentam juntar todos os segmentos
            do display sem deixar com que o separador de decimal se torne parte de
            algum número. Utilizando o elemento estrutural em formato de elipse e
            modificando o tamanho do elemento entre 3x3 e 2x2, foi possível fazer
            um "ajuste fino" após várias tentativas.</p>
        </div>
        <div class="paragraph">
          <p>Imagem original:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//clock.png" alt="clock">
          </div>
        </div>
        <div class="paragraph">
          <p>Imagem após várias dilatações e erosões:</p>
        </div>
        <div class="imageblock">
          <div class="content">
            <img src="image//clock_morf.png" alt="clock morf">
          </div>
        </div>
                <div class="listingblock">
          <div class="content">
            <pre class="highlight"><code class="language-C++" data-lang="C++">#include &lt;iostream&gt;
#include "opencv2/opencv.hpp"
#include &lt;iostream&gt;

  
  int main(int argc, char** argv) {
    cv::Mat image, erosao, dilatacao, abertura, fechamento, abertfecha;
    cv::Mat str;
    cv::Mat img1, img2;
  
    if (argc != 2) {
      std::cout << "morfologia entrada saida\n";
    }
  
    image = cv::imread(argv[1], cv::IMREAD_UNCHANGED);
  
  
    if(image.empty()) {
      std::cout << "Erro ao carregar a imagem: " << argv[1] << std::endl;
      return -1;
    }
  
    // elemento estruturante
    str = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
  
  
    cv::dilate(image, img1, str);
    str = cv::getStructuringElement(cv::MORPH_ELLIPSE , cv::Size(2, 2));
    cv::dilate(img1,img2,str);
    cv::dilate(img2, img1, str);
    cv::dilate(img1,img2,str);
  
    str = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
    cv::erode(img2, img1, str);
    cv::erode(img1, img2, str);
    cv::erode(img2, img1, str);
    cv::erode(img1, img2, str);
    cv::erode(img2, img1, str);
    cv::erode(img1, img2, str);
    cv::erode(img2, img1, str);
    str = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(2, 2));
    cv::erode(img1, img2, str);
  
    str = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
  
    cv::dilate(img2, img1, str);
    cv::dilate(img1,img2,str);
    cv::dilate(img2, img1, str);
    cv::dilate(img1,img2,str);
    cv::dilate(img2, img1, str);
    cv::dilate(img1,img2,str);
    cv::dilate(img2, img1, str);
  
    str = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(3, 3));
    cv::erode(img1, img2, str);
    cv::erode(img2, img1, str);
    cv::erode(img1, img2, str);
    cv::erode(img1, img2, str);
    cv::erode(img2, img1, str);
  
  
    cv::Mat matArray[] = {image, img1, img2};
    cv::hconcat(matArray, 3, image);
  
    cv::imshow("morfologia", image);
    cv::imwrite("clock_morf.png",img1);
  
    cv::waitKey();
    return 0;
  }
  
}</code></pre>
          </div>
        </div>
      </div>
    </div>
      </div>
    </div>
  </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({ messageStyle: "none", tex2jax: { inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]], ignoreClass: "nostem|nolatexmath" }, asciimath2jax:
    { delimiters: [["\\$", "\\$"]], ignoreClass: "nostem|noasciimath" }, TeX: { equationNumbers:
    { autoNumber: "none" } } });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>

</html>